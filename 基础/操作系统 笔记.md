[TOC]

# 第一章、操作系统概述

## 1 定义

> 操作系统是计算机中的一个**系统软件**，它是这样一些程序模块的***集合***——它们管理和控制计算机系统中的硬件和软件资源，合理地组织计算机的工作流程，以便有效地利用这些资源为用户提供一个具有**足够的功能**，**使用方便**，**可扩展**，**安全和可管理的**工作环境，从而在计算机与其用户之间起到***接口***的作用。

## 2 五大功能

> 1. ### 处理机管理
> 2. ### 存储管理
> 3. ### 设备管理
> 4. ### 文件系统管理
> 5. ### 用户接口

## 3 四个主要特点

> * ### 可靠性
>
> * ### 安全性
>
> * ### 可用性
>
> * ### 可管理性 
>

## 4 基本类型

>* ### 批处理操作系统
>
>* ### 分时系统
>
>* ### 实时系统
>
>* ### 通用操作系统
>
>* ### 个人计算机操作系统
>
>* ### 网络操作系统
>
>* ### 分布式操作系统





# 第二章、用户接口



# 第三章、进程管理



## 3.1 进程基本概念

为了能够精确地描述和研究程序在系统中运行的情况，引入了进程的概念。

进程是 **处于执行状态中的程序**，是现代操作系统一个**基本运行单位**。



## 3.2 Berstein 条件

对于 $S1,S2$ 两条语句，如果有

1. $R(S1)\cap W(S2)=\empty$
2. $R(S2)\cap W(S1)=\empty$
3. $W(S1)\cap W(S2)=\empty$

则 $S1,S2$ 可以并发执行



## 3.3 进程的描述



### 3.3.1 进程的上下文

**定义：**进程的**物理实体**与**支持进程执行的物理环境**的合称



## 3.4 进程的状态以及切换



### 3.4.1 进程的基本状态

1. 执行

   > 该进程已获得运行所必需的资源，它的程序正在处理机上     执行。

2. 阻塞

   > 进程正等待着某一事件的发生而暂时停止执行。这时， 即使给它CPU控制权，它也无法执行。

3. 就绪

   > 进程已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行。

4. 挂起状态

   > 把处于阻塞状态（或就绪状态）的进程暂时交换到外存时的状态。



## 3.5 线程

**定义：**线程是比进程更小的活动单位，它是进程中的一个 **执行路径**。

**线程的描述：**

- 是进程内的基本调度单位； 

- 也称为轻权进程（Light Weight Process，LWP）； 

- 可以由操作系统内核控制，也可以由用户程序来控制，是程序中的一个单一的顺序控制流。 

- 在多线程操作系统中，一个进程通常包括多个线程，即意味着一个程序内的多条语句同时执行。



### 3.5.1 进程与线程的区别

1. 进程为**资源分配**的基本单位，线程为操作系统的基本**调度单位**，而进程则为系统资源的拥有者。
2. 当进程发生调度时，它拥有一个完整的虚拟地址空间；同一进程内的不同线程**共享其所属进程的同一地址空间**。
3. 线程只由相关堆栈、寄存器和**线程控制块（TCB）**组成。
4. **进程切换**时涉及到有关资源指针的保存以及地址空间的变化；同一进程内的各线程共享其所属进程的资源和地址空间，切换时无需保存资源，无地址空间变化。
5. 进程的调度与切换由**操作系统内核完成**，线程的调度即可由操作系统完成，也可由用户完成。
6. 在多线程操作系统中，线程是系统内的**执行实体**，而进程不是。
7. 一个进程内的各个线程以及不同进程内的各个线程均可并发执行，在**多处理机系统**中它们可以被分派到不同的CPU上并行执行。



# 第四章、处理机管理



## 4.1 分级调度

1. **作业调度**
   - 高级调度或宏观调度
   - 按照某种算法从后备作业队列中选择一个或多个作业装入内存
   - 在作业运行结束后做善后处理
   - 完成作业调度功能的程序称为**作业调度程序** 
   - 作业调度程序 **回收分配资源**，善后处理
   
2. **交换调度**

   - 中级调度

   - 功能是在内、外存间进行信息交换
   - 实现虚拟存储管理

3. **进程调度**

   - 低级调度或微观调度
   - 它 **协调** 和 **控制** 各进程对处理机的使用
   - 相应的进程调度程序称为 **分派程序** 或 **低级调度程序**
   - 按照一定的准则合理的将处理机 **动态地分配** 给处于就绪队列中的某个进程

4. 线程调度

   - 低级调度或微观调度
   - **用户级线程** 和 **核心级线程** 调度的方式是不同的
   - 用户级线程由 **线程库** 进行管理和调度，称为进程 **局部调度**
   - 核心级线程则由 **系统内核** 来调度，称为系统 **全局调度**



**4级调度**的关系：

![4级调度](assets/4级调度.png)



## 4.2 调度算法

1. FCFS调度算法

2. **优先级调度算法**

3. 轮转调度

   > **基本思想：**将CPU的处理时间分成固定大小的**时间片**，将CPU轮流分配给各个进程，为各进程提供服务。
   >
   > 
   >
   > - 一个进程被用时间片而未执行结束，则释放CPU，并插入到就绪队列的末尾
   > - 阻塞队列中的进程因被唤醒而插入到就绪队列的末尾，等待分配CPU。
   >
   > **缺点：**进程切换频繁
   >
   > 
   >
   > **轮转调度法的分类：**根据每一轮的时间片是否可变可分为：
   >
   > 1. 固定周期轮转法：时间片常数
   > 2. 可变周期轮转法：开始时计算时间片
   >
   > 
   >
   > 轮转调度法特别适合分时系统使用。
   >
   > 
   >
   > **时间片长度的选择：**
   >
   > 根据系统对响应时间的要求R和就绪队列中所允许的最大进程数N来确定的。它可表示为：
   > $$
   > q=\frac{R}{N}
   > $$
   > **加入到就绪队列的进程有三种情况：**
   >
   > 1. 分给它的时间片用完，但进程还未完成。
   > 2. 当阻塞解除之后再回到就绪队列。
   > 3. 新创建进程进入就绪队列。

4. 分级轮转调度

   > **基本思想：**根据进程 **性质或优先级** 的不同将处于就绪状态的进程组成 **两个或多个** 就绪队列，先调度高优先级就绪队列中的进程，再调度低优先级就绪队列中的进程。
   >
   > **优缺点：**实现简单，调度程序开销少，但不灵活。

5. 分级反馈轮转调度

   > **基本思想：**
   >
   > 1. 根据对处理器的需求及占有情况把进程放入不同的就绪队列。
   > 2. 如果某个进程 **占用了太多** 的处理器时间，降低该进程的优先级，插入较低优先级队列中。
   > 3. 将 **长时间等待** 于较低优先级队列中的进程取出赋予较高的优先级，插入较高优先级队列中。

6. **最短作业优先调度**

   > **基本思想：**短作业或短进程优先进行调度CPU。
   >
   > **特点：**系统的吞吐量大，但处理时间长的作业可能长时间得不到服务。

7. **响应比优先调度**

   > **基本思想：**该方法以响应比作为作业调度的优先级，响应比越高，作业得到调度的优先级就越高。
   >
   > **响应比的定义Rp如下：**
   > $$
   > R_p=1+\frac{等待时间}{被要求执行的时间}
   > $$
   > **优点：**
   >
   > 1. 既考虑了作业到达的先后顺序
   > 2. 也适当照顾了短作业
   >
   > **缺点：**
   >
   > 1. 每次要调度作业时都要计算响应比
   > 2. 增加一定的系统开销



## 4.3 选择调度方式和评价调度算法的若干准则

   

1. CPU的利用率:运行时间与总时间之比
2. 系统吞吐率：单位时间完成作业数
3. 周转时间：提交到完成的时间
4. 带权周转时间：周转时间与运行时间的比  
5. 等待时间  
6. 响应时间  
7. 公平：均等机会得到调度  
8. 对资源的均衡使用



## 4.4 实时调度算法



### 4.4.1 实时操作系统的特点

根据对 **延迟** 的约束要求可分为：

1. **硬实时任务：**如果系统对任务的响应时间超出了给定的时限（deadline）,将会引起灾难性后果
2. **软实时任务：**允许系统对任务的响应具有一定的延迟。



根据**任务发生的时间**特征实时任务分为：

1. **周期性任务：**周期内完成任务
2. **非周期性任务：**在规定时限前开始或完成



**实时操作系统基本特征：** 

1. 支持多线程和可抢占式调度
2. 有限等待时间和响应时间
3. 可靠性高，健壮性强
4. 操作系统的行为应该被用户所了解和掌握



### 4.4.2  实现实时调度的基本条件

1. 提供必要的信息

   > 1. 就绪时间
   > 2. 开始时限和完成时限
   > 3. 处理时间
   > 4. 资源要求
   > 5. 优先级

2. 系统处理能力强

3. 采用 **抢占式调度** 机制

4. 具有 **快速** 的任务切换机制



### 4.4.3 实时调度算法的分类

按调度方式的不同：

- 非抢占式
  - 轮转调度
  - 优先调度
- 抢占式
  - 基于时钟中断
  - 立即抢占



### 4.4.4 几种常用的实时调度算法



1. **时限调度算法**

   > **基本思想：**按用户的时限要求设置优先级，时限越近，要求赋予的优先级越高，应优先占有处理机。
   >
   > 

2. **频率单调调度算法**

   > 频率单调调度算法以任务发生的频率作为调度的准则，发生频率高的任务则具有较高的优先级。
   >
   > 对于有m（m>1）个周期性的硬实时任务系统，每个任务的处理时间表示$C_i$，周期时间表示$T_i$，使用频率单调调度算法时的 **充分条件** 是：
   > $$
   > \frac{C_1}{T_1}+\frac{C_2}{T_2}+\cdots+\frac{C_n}{T_n}\leq m(2^{\displaystyle\frac{1}{m}}-1)
   > $$
   > 对于有m（m>1）个周期性的硬实时任务系统，每个任务的处理时间表示Ci，周期时间表示Ti，使用频率单调调度算法时的 **必要条件** 是：
   > $$
   > C_i \leq T_i
   > $$
   > 

# 第五章、存储管理

## 5.1 存储管理的功能



### 5.1.1 内存的分配与回收

### 5.1.2 地址转换

1. 静态地址重定位

   > **完成时间：**在程序执行之前由装配程序完成地址转换工作
   >
   > **优点：**不需要硬件支持
   >
   > **缺点：**无法实现虚拟存储器。程序和数据的共享难

2. 动态地址重定位

   > **完成时间：**程序执行过程中，将要访问的程序或数据的逻辑地址转换成内存地址
   >
   > **所需资源：**需要一个(或多个)基地址寄存器BR一个(或多个)程序逻辑地址寄存器VR。
   >
   > **地址变换：**MA（内存地址）=（BR）+（VR）
   >
   > **优点：**
   >
   > - 可以对内存进行非连续分配
   > - 提供了实现虚拟存储器的基础
   > - 可以分存在不同内存区域，有利于程序段的共享



### 5.1.3 内存的信息共享与保护



**保护方法：**

- 硬件法；如上下界保护法。

  > 为每个运行着的进程和数据段设置一对上下界寄存器。访问操作时，对起始地址和终止地址进行合法性检查。

- 软件法；如保护键法。

  > 为每一个被保护存储块分配一个单独的保护键。

- 软硬件结合法。

  > 是界限寄存器与CPU的用户态或核心态工作方式相结合的保护方式。



### 5.1.4   内存的扩充

**目的：**实现系统运行的作业大小只受内存容量和外存容量之和的限制





**实现：**

1. 程序的全部代码和数据存放在**辅存**中；
2. 将程序当前执行所涉及的那部分程序代码放入**主存**中；
3. 程序执行时，当所需信息不在主存，由操作系统和硬件相配合来完成主存从辅存中**调入信息**，程序继续执行。



## 5.2 覆盖和交换技术



### 5.2.1 覆盖技术

**基本思想：**

- 把程序划分为若干个功能上相对独立的程序段；
- 按照程序的逻辑结构让那些**不会同时执行**的程序段共享同一块内存区。
- 这些程序段都被保存在**外存**中；
- 当有关程序段的先头程序段已经执行结束后，再把后续程序段调入内存**覆盖**前面的程序段。
- 用户看来好像内存扩大了，从而达到了内存扩充的目的。



**实现：**

1. 程序员提供**覆盖描述文件**——程序员必须完成把一个程序划分成不同的程序段，并规定好它们执行和覆盖顺序
2. 操作系统根据程序员提供的覆盖描述文件来完成程序段之间的覆盖。



适用：覆盖技术大多由对操作系统的**虚拟空间和内部结构**很熟悉的程序员来使用。



### 5.2.2 交换技术

**含义：**

- 将内存某部分的程序或数据写入外存交换区
- 从外存交换区中调入指定的程序或数据到内存



## 5.3 分区存储管理

**基本思想：**把用户区作为一个连续区或分成若干个连续区进行管理，当划分多个连续区时，可采用 **固定分区** 方式或 **可变分区** 方式进行管理。



### 5.3.1 单分区存储管理

**基本思想：**用户区作为 **一个** 连续分区分配给一个作业使用，任何时刻，主存只存在 **一个** 作业



**特点：**

- 设置一个界限寄存器记录用户区的起始地址。
- 每次只允许一个作业装入主存储器。 
- 可以采用静态重定位的方式进行地址转换。 



### 5.3.2 多分区存储管理

**基本思想：**把主存中的用户区划分成若干个连续区域，每个连续区中可装入一个作业。



#### 5.3.2.1 固定分区存储管理

**基本思想：**

- 把主存的用户区域预先划分成若干个连续区。
- 每个连续区的大小可以相同，也可以不同。
- 划分好分区之后，个数和大小都不能改变
- 每个分区可用来装入一个作业。



**使用的数据结构：**主存分配表

| 分区号 | 起始位置 | 长度 | 占用标志 |
| ------ | -------- | ---- | -------- |



**地址转换：**采用静态重定位的方式



#### 5.3.2.2 可变分区存储管理

**使用的数据结构：**

1. 已分配表

   | 起始地址 | 长度 | 标志位 |
   | -------- | ---- | ------ |

   

2. 未分配表

   | 起始地址 | 长度 | 标志位 |
   | -------- | ---- | ------ |

3. 空闲块链

   > 空闲块链是由链表实现的，链表中的每一个节点记录一个空闲块的大小和下一个空闲块的起始地址。



**分配算法：**

1. 最先适应

   > 每次分配时，总是顺序查找空闲区表，找到 **第一个能满足作业长度要求** 的空闲区。
   >
   > 把空闲区按 **首地址顺序从小到大** 登记在空闲区表中。
   >
   > 每当有作业归还分区时，必须调整空闲区表

2. 最佳适应

   > 按作业要求挑选一个能满足作业要求的 **最小** 空闲区。
   >
   > 把空闲区按 **大小顺序从小到大** 登记在空闲区表中。
   >
   > 形成小空闲区（即“碎片”）无法使用的，影响了主存空间的使用率

3. 最坏适应

   > 总是挑选一个 **最大** 的空闲区分割一部分给作业使用。
   >
   > 空闲区表中的登记项可按空闲区 **大小以递减顺序** 排列



**地址转换：**

- 采用动态重定位

- 硬件设置两个专用的控制寄存器：限长寄存器：存放作业所占分区的长度；基址寄存器:存放作业所占分区的起始地址



**作业的装入方式：**

1. 一头装入
2. 两头装入





## 5.4 页式存储管理



**基本原理：**

- 把主存分成大小相等 “块”，逻辑空间分成与块大小的“页“。

- 逻辑地址组成：页号和页内地址逻辑地址是一维的



### 5.4.1 分类

1. [静态页式存储](#5.4.3 静态页式存储管理)

2. [动态页式存储](#5.4.4 动态页式存储管理)



### 5.4.2 使用的数据结构

####  5.4.2.1 页表

一个**进程**，维护一个页表，用来记录一个进程所占用内存的情况。

页表项目数 = 进程的页数



结构：

| 页号（page） | 块号（page frame） |
| :----------: | :----------------: |



#### 5.4.2.2 请求表

整个**系统**，维护一个请求表，用来记录所有进程 **申请/占用** 内存的情况

记录项目是**进程**



结构：

| 进程号 | 请求块数 | 页表起始地址 | 页表长度 |
| :----: | :------: | :----------: | :------: |



#### 5.4.2.3 存储块表

整个**系统**，维护一个存储块表，用来记录内存各个块的 **占用/空闲** 情况

记录项目是**内存块**



 表示方法

##### 1）位示图法

在内存空间中划分一个固定区域，这个区域的每个bit表示一个内存块的状态。

##### 2）空闲块表

每一项记录一组 **连续** 的空闲区域



结构：

| 首块号 | 连续空闲块数 |
| ------ | ------------ |



##### 3）空闲块链

节点结构：

1. 连续空闲区域总块数
2. 下一个连续空闲区首块位置

头节点：

​	首个连续空闲区首块位置



### 5.4.3 静态页式存储管理

在进程**开始执行之前**，将该进程程序段和数据段按页**全部装入**内存。

#### 分配

检查位示图中的空闲块数是否满足该进程的要求？

若不满足，进程等待；

若满足，则根据需求从位示图找出标记0的块，并置1。

从空闲块总数中减去本次分配的块数。

按位计算块号（块号 = 字号*字长+位号）

把进程装入这些块中。

建立一张页表。

#### 回收

按页表查找对应的块号

归还这些块：

​	计算块在位示图中的位置（字号=块号/字长）（位号 = 块号 mod 字长）

​	将该bit置0

​	空闲块数+1

#### 地址转换

按逻辑地址查到 **页号**

在页表中查到 **块号**

计算公式：$绝对地址 = 块号 \times 块长 + 页内地址$



在多道程序设计的系统时，为了保证每个进程按照该进程的页表进行地址转换。

需要增加一个硬件——**页表控制寄存器**，页表始址存入基址寄存器，页表长度送入限长寄存器。

当调度程序选中某个进程占用处理机的时，通过 **请求表** 查找该进程的页表起始地址和长度，送入页表控制寄存器。





### 5.4.4 动态页式存储管理

将进程信息作为副本放在磁盘上存储，在进程执行时，将进程信息**部分页面**调入主存。

若执行时，所访问页面已在主存中，则按静态页式存储管理的方式进行地址转换；

若访问的页面不在主存中，则产生一个 **缺页中断**，由操作系统将页面调入主存。

 

在装入进程时，就应该知道哪些页被装入了主存，哪些页没有被装入。

为此**改进的页表结构**如下：

| 页号 | 页面号 | 标志位 | 外存地址 | 改变位 |
| ---- | ------ | ------ | -------- | ------ |



当在进程的执行中，要访问某页时，地址转换机构去查找页表，若该页号标志位为1，则表示在主存；若为0，则表示不在主存





#### 5.4.4.1 页面置换

当主存中无空闲块时，为了装入一个页而必须按某种算法从已在主存的页中选择一页，将它暂时调出主存，让出主存空间，用来存放所需装入的页面



1. 随机置换算法

   > 随机地选择某个用户的页面并将其换出。

2. 轮转置换算法

   > 轮流换出用户区内的一个可以被换出的页。

3. **先进先出置换算法**

   > - 选择最先装入主存储器的那一页调出
   > - 把驻留在主存中时间最长的那一页调出。

4. **最近最少用置换算法**

   > - 基于程序执行的局部性；
   > - 访问到某些数据和指令时可能在一段时间里还经常会访问它们，不应该把这些页面调出。
   > - 某个内存页在最近一段时间里没有被访问过，则在最近的将来也可能暂时不会被访问，可以选择这些页面调出。

5. 最近不常用置换

   > - 为每一页设置一个计数器，每当访问一页时，就把该页对应的计数器加1；
   > - 操作系统确定一个周期T，在周期T的时间内，若没有发生缺页中断，则把所有的计数器清“0”，开始一个新的周期重新计数。
   > - 若在周期T的时间内发生了缺页中断，则选择计数值最小的那页调出(它是最近一段时间内最不常用的页)，同时把所有的计数器清“0”；
   > - 算法的实现要花很大的开销，并且要确定一个合适的周期T也是困难的。

6. CLOCK置换算法

   > 1. 简单的Clock置换算法
   >
   >    > - 为每一页设置一位访问位，内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置1。 
   >    >
   >    > - 如果访问位为 0，就选择该页换出，若为1，则重新将它置0，暂不换出，再按照FIFO算法检查下一个页面。
   >    >
   >    > 规则:
   >    >
   >    > 1. 首次装入：置1
   >    > 2. 刚使用过：置1
   >    > 3. 查找过：置0
   >    > 4. 遇到第一个0：替换
   >    > 5. 指针指向下一个
   >
   > 2. 改进的Clock置换算法
   >
   >    > 考虑页面的使用情况，增加一个因素，置换代价。
   >    >
   >    > 由访问位A和修改位M可以组合成四种类型页面：  
   >    >
   >    > 1类（A=0，M=0）：表示该页最近既未被访问，又未被修改，是最佳淘汰页；   
   >    >
   >    > 2类（A=0，M=1）：表示该页最近未被访问，但被修改，并不是很好的淘汰页；
   >    >
   >    > 3类（A=1，M=0）：表示该页最近已被访问，但未被修改，有可能再被访问；
   >    >
   >    > 4类（A=1，M=1）：表示该页最近被访问且被修改，有可能再被访问；
   >    >
   >    > 
   >    >
   >    > 执行步骤：
   >    >
   >    > 1. 扫描循环队列，寻找第1类页面（ A=0，M=0 ），将它淘汰，不改变访问位A。
   >    > 2. 如果（1）步骤失败，开始第二轮扫描，寻找第2类页面（ A=0，M=1），将它淘汰，改变访问位A=0。
   >    > 3. 如果（2）步骤失败，改变所有页访问位A=0，然后重复步骤（1），必要时重复步骤（2）。

7. 页面缓冲算法

   > 该算法规定将一个被淘汰的页放入两个链表中的一个：
   >
   > ①如果页面未被修改，就特将它直接放入空闲链表中；
   >
   > ②如果页面被修改，便放入已修改页面的链表中。
   >
   >  须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。 
   >
   >  既可改善分页系统的性能，又可采用一种较简单的置换策略。        

8. 最佳置换算法

   > 当要装入一个新页而必须调出一个页面时，所选择的调出页应该是以后再也不使用的页或者是距当前最长时间以后才使用的页。



## 5.5 段式和段页式存储



# 第六章、文件管理

   文件系统主要对以文件形式存放在 **外部存储器** 上的信息进行管理。

包括：

- 如何以文件形式组织信息；
- 如何通过文件名对存储在存储介质上的文件进行操作；
- 如何实现文件的共享、保护和保密；
- 如何提高文件系统的可靠性；
- 如何对外部存储空间进行有效管理。



    ## 6.1 文件

1. 什么是文件

   > 文件是在逻辑上具有完整意义的信息集合，它有一个名字以供标识，文件名是以字母开头的字母数字串。



# 第七章、设备管理

# 第八章、进程的互斥、同步、死锁

